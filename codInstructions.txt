DATA [15:0]
OPCODE [15:10]

rA,rC 	=> registrador fonte
rBranch => registrador auxiliar para condicional
rB 		=> registrador escrita
imm 	=> constante
exc 	=> bits não utilizados 


================================================= INSTRUÇÕES =====================================================

INSTRUÇÕES				:								CODIFICAÇÃO										#	AÇÃO			 		#	OPCODES	
0. nop					:	 0000000000000000															#	nop						# 	000000
1. add rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rA + rB			#	001000
2. sub rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rB - rA			#	001001
3. bgt rA, rC			:	 opcode(15 downto 10), rA(9 downto 7), rC(6 downto 4), imm(3 downto 0)		#	rA>=rC (pc<=pc+imm)		#	001010
4. and rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rB and rA			#	001011
5. xor rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rB xor rA			#	001100
6. not rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= not(rA)			#	001101
7. mov imm, rB			:	 opcode(15 downto 10), rA(9 downto 7), imm(6 downto 0)						#	rB <= imm 				#	010000
8. mov rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rA				#	010001
9. add imm, rB			:	 opcode(15 downto 10), rB(9 downto 7), imm(6 downto 0)						#	rB <= imm + rB			#	010010
10.jump rA 				:	 opcode(15 downto 10), rA(9 downto 7), exc(6 downto 0)						#	ABSOLUTE JUMP			#	111111
11.lw 




============================================ PROGRAMAS EXECUTADOS ==================================================

# CÓDIGO 1:

 

ASSEMBLY:						BINÁRIO:				HEX:
1. mov 0, $r3					=> 010000 011 0000000	=> OX4180
2. mov 0, $r4					=> 010000 100 0000000	=> 0X4200
3. mov 30, $r2					=> 010000 010 0011110	=> 0X411E
4. add $r3, $r4					=> 001000 011 100 0000	=> 0X21C0
5. add 1, $r3					=> 010010 011 0000001	=> 0X4981
6. bgt $r2, $r3					=> 001010 010 011 1110	=> 0X2930
7. mov $r4, $r5					=> 010001 100 101 0000	=> 0X4650

ROM:
			 0 	=> "0100000110000000", -- mov 0, $r3
			 1 	=> "0100001000000000", -- mov 0, $r4
			 2 	=> "0100000100011110", -- mov 30, $r2
			 3 	=> "0010000111000000", -- add $r3, $r4
			 4 	=> "0100100110000001", -- add 1, $r3
			 5 	=> "0010100100111110", -- bgt $r2, $r3
			 6 	=> "0100011001010000", -- mov $r4, $r5
			 7 	=> "0000000000000000",
			 8  => "0000000000000000",  
			 9 	=> "0000000000000000",  
			 10 => "0000000000000000",
			 11 => "0000000000000000",  
			 12 => "0000000000000000",  
			 13 => "0000000000000000", 
			 14 => "0000000000000000",  
			 15 => "0000000000000000",  
			 16 => "0000000000000000",  
			 17 => "0000000000000000",  
			 18 => "0000000000000000",  
			 19 => "0000000000000000",  
			 20 => "0000000000000000", 
			 21 => "0000000000000000", 
			 22 => "0000000000000000", 

# CÓDIGO 2:

ASSEMBLY:						BINÁRIO:				HEX:
1. 	mov 5, $r3					=> 010000 011 0000101 	=> 0x4185
2. 	mov 8, $r4					=> 010000 100 0001000 	=> 0x4208
3. 	add $r4, $r3				=> 001000 100 011 0000	=> 0x2230
4. 	mov $r3, $r5				=> 010001 011 101 0000	=> 0x45D0
5. 	add -1, $r5					=> 010010 101 1111111	=> 0x4AFF
6. 	mov 20, $r1					=> 010000 001 0010100	=> 0x4094
7. 	jump $r1					=> 111111 001 0000000	=> 0xFC80
8.	mov $r5, $r3				=> 010001 101 011 0000	=> 0x46B0
9. 	mov 2, $r1					=> 010000 001 0000010	=> 0x4082
10. jump $r1					=> 111111 001 0000000	=> 0xFC80 

ROM:
			 0 	=> "0100000110000101", -- mov 5, $r3
			 1 	=> "0100001000001000", -- mov 8, $r4
			 2 	=> "0010001000110000", -- add $r4, $r3
			 3 	=> "0100010111010000", -- mov $r3, $r5
			 4 	=> "0100101011111111", -- add -1, $r5	
			 5 	=> "0100000010010100", -- mov 20, $r1
			 6 	=> "1111110010000000", -- jump 20($r1)
			 7 	=> "0000000000000000",
			 8  => "0000000000000000",  
			 9 	=> "0000000000000000",  
			 10 => "0000000000000000",
			 11 => "0000000000000000",  
			 12 => "0000000000000000",  
			 13 => "0000000000000000", 
			 14 => "0000000000000000",  
			 15 => "0000000000000000",  
			 16 => "0000000000000000",  
			 17 => "0000000000000000",  
			 18 => "0000000000000000",  
			 19 => "0000000000000000",  
			 20 => "0100011010110000", -- mov $r5, $r3
			 21 => "0100000010000010", -- mov 2, $r1
			 22 => "1111110010000000", -- jump 2($r1)

# CÓDIGO 3:
ASSEMBLY:						BINÁRIO:				HEX:

1. 	mov 2, $r3					=> 010000 011 0000010 	=> 0x4185
2. 	mov 5, $r4					=> 010000 100 0000101 	=> 0x4208
3. 	add $r4, $r3				=> 001000 100 011 0000	=> 0x2230
4. 	mov $r3, $r5				=> 010001 011 101 0000	=> 0x45D0
5. 	mov 3, $r1					=> 010000 001 0000011	=> 0x4094
6.	jump $r1					=> 111111 001 0000000	=> 0xFC80 

ROM:
			 0 	=> "0000000000000000", 
			 1 	=> "0100000110000010",
			 2 	=> "0100001000000101",
			 3 	=> "0010001000110000",
			 4 	=> "0100010111010000", 
			 5 	=> "0100000010000011", 
			 6 	=> "1111110010000000", 
			 7 	=> "0000000000000000",
			 8  => "0000000000000000",  
			 9 	=> "0000000000000000",  
			 10 => "0000000000000000",
			 11 => "0000000000000000",  
			 12 => "0000000000000000",  
			 13 => "0000000000000000", 
			 14 => "0000000000000000",  
			 15 => "0000000000000000",  
			 16 => "0000000000000000",  
			 17 => "0000000000000000",  
			 18 => "0000000000000000",  
			 19 => "0000000000000000",  
			 20 => "0000000000000000",
			 21 => "0000000000000000",
			 22 => "0000000000000000", 