DATA [15:0]

OPCODE [15:12]

NOP => OPCODE = 0000
JUMP => OPCODE =  1111
R => OPCODE =  0001
I => OPCODE = 1000, 1001

Formato R: opcode(4) , 		$rs(3),		  $rt(3), 		$rd(3),		 function(3)
		(15 downto 12)	 (11 downto 9)  (8 downto 6)   (5 downto 3)	  (2 downto 0)

Formato I: opcode(4) , 		$rs(3), 		 $rt(3), 		immediate(6)
        (15 downto 12)   (11 downto 9)    (8 downto 6)     (5 downto 0)

-------------------- ASSEMBLY : Formato R --------------------

add $rd, $rs, $rt, 000			# Soma o valor de $rs e $rt e armazena em $rd ($rd <= $rs + $rt)
sub $rd, $rs, $rt, 001			# Subtrai o valor de $rt em $rs e armazena em $rd ($rd <= $rs - $rt)
and $rd, $rs, $rt, 011			# Executa a operação AND entre os valores de $rt e $rs
xor $rd, $rs, $rt, 100			# Executa a operação XOR entre os valores de $rt e $rs
nor $rd, $rs, $rt, 101			# Executa a operação NOR entre os valores de $rt e $rs

-------------------- ASSEMBLY : Formato I --------------------

addi $rt, $rs, immediate	# Soma constante ao valor de $rs e armazena em $rt ( $rt <= $rs + immediate) \\ OPCODE = "1000"
cpy $rt, $rs, immediate   # Passa o conteudo de $rs para $rt ( $rt <= $rs ) \\ OPCODE = "1001" 


=============== PROGRAMA EXECUTADO =============================

ASSEMBLY:						BINÁRIO:				HEX:

1. addi $r3, $zero, 5		=> 1000 000 011 000101 	=> 0x80C5
2. addi $r4, $zero, 8		=> 1000 000 100 001000 	=> 0x8108
3. add $r5, $r3, $r4, 000	=> 0001 011 100 101 000	=> 0x1728
4. addi $r5, $r5, -1		=> 1000 101 101 111111	=> 0x8B7F
5. jump 000000010100		=> 1111 000000010100	=> 0xF014
6. cpy $r3, $r4, 000000		=> 1001 100 011 000000	=> 0x98C0 @ADDRESS 000000010100
7. jump 000000000011		=> 1111 000000000011	=> 0xF003 