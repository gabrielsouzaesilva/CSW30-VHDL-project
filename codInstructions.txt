DATA [15:0]
OPCODE [15:10]

rA,rC 	=> registrador fonte
rBranch => registrador auxiliar para condicional
rB 		=> registrador escrita
imm 	=> constante
exc 	=> bits não utilizados 


================================================= INSTRUÇÕES =====================================================

INSTRUÇÕES				:								CODIFICAÇÃO										#	AÇÃO			 		#	OPCODES

OPCODE(6 downto 4) = 000	
0. nop					:	 0000000000000000															#	nop						# 	000000

OPCODE(6 downto 4) = 001
1. add rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rA + rB			#	001000
2. sub rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rB - rA			#	001001
3. bgt rA, rC,imm		:	 opcode(15 downto 10), rA(9 downto 7), rC(6 downto 4), imm(3 downto 0)		#	rA>=rC (pc<=pc+imm)		#	001010
4. and rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rB and rA			#	001011
5. xor rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rB xor rA			#	001100
6. not rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= not(rA)			#	001101
7. beq rA, rC, imm 		:	 opcode(15 downto 10), rA(9 downto 7), rC(6 downto 4), imm(3 downto 0)		#	rA=rC (pc<=pc+imm)		#	001110

OPCODE(6 downto 4) = 010
7. mov imm, rB			:	 opcode(15 downto 10), rA(9 downto 7), imm(6 downto 0)						#	rB <= imm 				#	010000
8. mov rA, rB			:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	rB <= rA				#	010001
9. add imm, rB			:	 opcode(15 downto 10), rB(9 downto 7), imm(6 downto 0)						#	rB <= imm + rB			#	010010

OPCODE(6 downto 4) = 011
10.sld.w rA, rB 		:	 opcode(15 downto 10), rA(9 downto 7), rB(6 downto 4), exc(3 downto 0)		#	LOAD (rB <=cont @ rA)	#	011000
11.st.w rA,rC 			:	 opcode(15 downto 10), rA(9 downto 7), rC(6 downto 4), exc(3 downto 0)		#	STORE (rC @ address rA) #	011001

OPCODE(6 downto 4) = 111
12.jump rA 				:	 opcode(15 downto 10), rA(9 downto 7), exc(6 downto 0)						#	ABSOLUTE JUMP			#	111111



============================================ PROGRAMAS EXECUTADOS ==================================================

!! VERIFICAR OPCODES !!
! ARRUMAR ULA E PROCESSADOR PARA BEQ 

# TESTE FINAL NUMEROS PRIMOS SATANICOS
ASSEMBLY:						BINÁRIO:				HEX:	

# Inicializa registradores (OK)
0.	mov 12, $r5					=> 010000 101 0001100 	=>
1.	mov 23, $r6					=> 010000 110 0010111	=>
2.	mov 13, $r7					=> 010000 111 0001101	=>
3.	mov 35, $r2 				=> 010000 010 0100011	=>

# Loop adiciona 1 a 35 na RAM (OK)

4.	add 1, $r1 					=> 010010 001 0000001	=>
5.	st.w $r1, $r1 				=> 011001 001 001 0000	=>
6.	bgt $r2, $r1, -2			=> 001010 010 001 1110	=>

# Remoção não primos

7.	mov 2, $r1 					=> 010000 001 0000010	=>
8.	jump $r5(AQUI)				=> 111111 101 0000000
9.	jump $r6 (END)				=> 111111 110 0000000

10.	add 1, $r1 					=> 010010 001 0000001
11.	bgt $r1, $r2,-2				=> 001010 001 010 1110

12.	mov $r1, $r4 				=> 010001 001 100 0000	AQUI
13.	add 1, $r4 **				=> 010010 100 0000001 	
14.	mov $r4, $r3 				=> 010001 100 011 0000

15.	sub $r1, $r3 				=> 001001 001 011 0000
16. bgt $r3,$r0,-1				=> 001010 011 000 1111
	
17.	beq $r0, $r3, 3  			=> 001110 000 011 0011			jump->*	
18.	bgt $r4, $r2, -8			=> 001010 100 010 1000
19.	jump $r7 **					=> 111111 111 0000000

20.	st.w $r4, $r0 * 			=> 011001 100 000 0000		*
21.	bgt $r2, $r4, -8  			=> 001010 010 100 1000
22.	jump $r7					=> 111111 111 0000000
23. END

ROM:
			 0 	=>  "0100001010001100", --mov 12, $r5	
			 1 	=>  "0100001100010111", --mov 23, $r6	
			 2 	=>  "0100001110001101", --mov 13, $r7	
			 3 	=>  "0100000100100011", --mov 35, $r2 
			 4 	=>  "0100100010000001", --add 1, $r1 		
			 5 	=>  "0110010010010000", --st.w $r1, $r1 	
			 6 	=>  "0010100100011110", --bgt $r2, $r1, -2
			 7 	=>  "0100000010000010",
			 8  =>  "1111111010000000",  
			 9 	=>  "1111111100000000",  
			 10 =>  "0100100010000001",
			 11 =>  "0010100010101110",  
			 12 =>  "0100010011000000",  
			 13 =>  "0100101000000001", 
			 14 =>  "0100011000110000",  
			 15 =>  "0010010010110000",  
			 16 =>  "0010100110001111",  
			 17 =>  "0011100000110011",  
			 18 =>  "0010101000101000",  
			 19 =>  "1111111110000000",  
			 20 =>  "0110011000000000", 
			 21 =>  "0010100101001000", 
			 22 =>  "1111111110000000",
			 23 =>	"0000000000000000",


# TESTE RAM (LAB 07):

	#TESTE A (Funcionamento básico da RAM / armazenar e ler valores): 
ASSEMBLY:						BINÁRIO:				HEX:		

1.	mov 1, $r1						=> 010000 001 0000001	=> 0x4081
2.	mov 7, $r2						=> 010000 010 0000111	=> 0x4107
3.	st.w $r2, $r1					=> 011001 010 001 0000	=> 0x6510		Escreve no endereço 7, valor 1
4.	sld.w $r2, $r3					=> 011000 010 011 0000	=> 0x6130		Coloca em r3 o valor 1
5.	mov 7, $r2						=> 010000 010 0000111	=> 0x4107			
6.	mov 3, $r1						=> 010000 001 0000011	=> 0x4083
7.	st.w $r1, $r2					=> 011001 001 010 0000	=> 0x64A0		Escreve no endereço 3, valor 7
8.	sld.w $r1, $r4					=> 011000 001 100 0000	=> 0x60C0		Coloca em r4 o de valor 7
9.	add 1, $r1						=> 010010 001 0000001	=> 0x4881		R1 = 4
10.	add 1, #r2						=> 010010 010 0000001	=> 0x4901		R2 = 8
11.	st.w $r1, $r2					=> 011001 001 010 0000	=> 0x64A0		Coloca no endereço 4, valor 8
12.	sld.w $r1, $r4					=> 011000 001 100 0000	=> 0x60C0		Coloca em r4 o valor de 8

ROM:
			 0 	=>  "0100000010000001", 
			 1 	=>  "0100000100000111", 
			 2 	=>  "0110010100010000", 
			 3 	=>  "0110000100110000", 
			 4 	=>  "0100000100000111", 
			 5 	=>  "0100000010000011", 
			 6 	=>  "0110010010100000", 
			 7 	=>  "0110000011000000",
			 8  =>  "0100100010000001",  
			 9 	=>  "0100100100000001",  
			 10 =>  "0110010010100000",
			 11 =>  "0110000011000000",  
			 12 =>  "0000000000000000",  
			 13 =>  "0000000000000000", 
			 14 =>  "0000000000000000",  
			 15 =>  "0000000000000000",  
			 16 =>  "0000000000000000",  
			 17 =>  "0000000000000000",  
			 18 =>  "0000000000000000",  
			 19 =>  "0000000000000000",  
			 20 =>  "0000000000000000", 
			 21 =>  "0000000000000000", 
			 22 =>  "0000000000000000",

# CÓDIGO 1:

 

ASSEMBLY:						BINÁRIO:				HEX:
1. mov 0, $r3					=> 010000 011 0000000	=> OX4180
2. mov 0, $r4					=> 010000 100 0000000	=> 0X4200
3. mov 30, $r2					=> 010000 010 0011110	=> 0X411E
4. add $r3, $r4					=> 001000 011 100 0000	=> 0X21C0
5. add 1, $r3					=> 010010 011 0000001	=> 0X4981
6. bgt $r2, $r3,-2				=> 001010 010 011 1110	=> 0X2930
7. mov $r4, $r5					=> 010001 100 101 0000	=> 0X4650

ROM:
			 0 	=> "0100000110000000", -- mov 0, $r3
			 1 	=> "0100001000000000", -- mov 0, $r4
			 2 	=> "0100000100011110", -- mov 30, $r2
			 3 	=> "0010000111000000", -- add $r3, $r4
			 4 	=> "0100100110000001", -- add 1, $r3
			 5 	=> "0010100100111110", -- bgt $r2, $r3
			 6 	=> "0100011001010000", -- mov $r4, $r5
			 7 	=> "0000000000000000",
			 8  => "0000000000000000",  
			 9 	=> "0000000000000000",  
			 10 => "0000000000000000",
			 11 => "0000000000000000",  
			 12 => "0000000000000000",  
			 13 => "0000000000000000", 
			 14 => "0000000000000000",  
			 15 => "0000000000000000",  
			 16 => "0000000000000000",  
			 17 => "0000000000000000",  
			 18 => "0000000000000000",  
			 19 => "0000000000000000",  
			 20 => "0000000000000000", 
			 21 => "0000000000000000", 
			 22 => "0000000000000000", 

# CÓDIGO 2:

ASSEMBLY:						BINÁRIO:				HEX:
1. 	mov 5, $r3					=> 010000 011 0000101 	=> 0x4185
2. 	mov 8, $r4					=> 010000 100 0001000 	=> 0x4208
3. 	add $r4, $r3				=> 001000 100 011 0000	=> 0x2230
4. 	mov $r3, $r5				=> 010001 011 101 0000	=> 0x45D0
5. 	add -1, $r5					=> 010010 101 1111111	=> 0x4AFF
6. 	mov 20, $r1					=> 010000 001 0010100	=> 0x4094
7. 	jump $r1					=> 111111 001 0000000	=> 0xFC80
8.	mov $r5, $r3				=> 010001 101 011 0000	=> 0x46B0
9. 	mov 2, $r1					=> 010000 001 0000010	=> 0x4082
10. jump $r1					=> 111111 001 0000000	=> 0xFC80 

ROM:
			 0 	=> "0100000110000101", -- mov 5, $r3
			 1 	=> "0100001000001000", -- mov 8, $r4
			 2 	=> "0010001000110000", -- add $r4, $r3
			 3 	=> "0100010111010000", -- mov $r3, $r5
			 4 	=> "0100101011111111", -- add -1, $r5	
			 5 	=> "0100000010010100", -- mov 20, $r1
			 6 	=> "1111110010000000", -- jump 20($r1)
			 7 	=> "0000000000000000",
			 8  => "0000000000000000",  
			 9 	=> "0000000000000000",  
			 10 => "0000000000000000",
			 11 => "0000000000000000",  
			 12 => "0000000000000000",  
			 13 => "0000000000000000", 
			 14 => "0000000000000000",  
			 15 => "0000000000000000",  
			 16 => "0000000000000000",  
			 17 => "0000000000000000",  
			 18 => "0000000000000000",  
			 19 => "0000000000000000",  
			 20 => "0100011010110000", -- mov $r5, $r3
			 21 => "0100000010000010", -- mov 2, $r1
			 22 => "1111110010000000", -- jump 2($r1)

# CÓDIGO 3:
ASSEMBLY:						BINÁRIO:				HEX:

1. 	mov 2, $r3					=> 010000 011 0000010 	=> 0x4185
2. 	mov 5, $r4					=> 010000 100 0000101 	=> 0x4208
3. 	add $r4, $r3				=> 001000 100 011 0000	=> 0x2230
4. 	mov $r3, $r5				=> 010001 011 101 0000	=> 0x45D0
5. 	mov 3, $r1					=> 010000 001 0000011	=> 0x4094
6.	jump $r1					=> 111111 001 0000000	=> 0xFC80 

ROM:
			 0 	=> "0000000000000000", 
			 1 	=> "0100000110000010",
			 2 	=> "0100001000000101",
			 3 	=> "0010001000110000",
			 4 	=> "0100010111010000", 
			 5 	=> "0100000010000011", 
			 6 	=> "1111110010000000", 
			 7 	=> "0000000000000000",
			 8  => "0000000000000000",  
			 9 	=> "0000000000000000",  
			 10 => "0000000000000000",
			 11 => "0000000000000000",  
			 12 => "0000000000000000",  
			 13 => "0000000000000000", 
			 14 => "0000000000000000",  
			 15 => "0000000000000000",  
			 16 => "0000000000000000",  
			 17 => "0000000000000000",  
			 18 => "0000000000000000",  
			 19 => "0000000000000000",  
			 20 => "0000000000000000",
			 21 => "0000000000000000",
			 22 => "0000000000000000", 